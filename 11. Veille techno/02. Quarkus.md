
![[Pasted image 20260213093523.png]]

---
## Contexte : Pourquoi Quarkus ?

**Applications modernes** -> cloud, microservices, containers
Besoin :
- démarrage rapide
- faible consommation mémoire
- scaling automatique *(capacité d’un système informatique à augmenter ou diminuer automatiquement ses ressources selon la charge réelle.)*

%%Les frameworks Java classiques fonctionnent bien, mais ils n’ont pas été conçus dès le départ pour ce fonctionnement cloud.%%

---
## Qu’est-ce que Quarkus ?

- Quarkus est un framework Java moderne **V1.0 : novembre 2019**
- Conçu pour les applications **cloud-native** 
- Compatible JVM et native image (GraalVM)


> [!tip]
> ##### JVM 
>  - Tu pars pour une réparation avec une énorme boîte à outils, même si tu n’utilises que 10 outils.
> ##### Native Image
>  - Tu prépares uniquement les outils nécessaires avant de partir.


%% Quarkus optimise Java pour qu’il fonctionne efficacement dans des environnements cloud.%%

---
## Le principe clé

### Build-time vs Runtime

|                       | Spring       | Quarkus     |
| --------------------- | ------------ | ----------- |
| Analyse               | au démarrage | au build    |
| Startup               | + long       | très rapide |
| Mémoire               | + élevée     | + faible    |
| Cloud / microservices | Oui          | Conçu pour  |

> [!tip]
> Spring privilégie la flexibilité en réalisant beaucoup d’analyse au démarrage, tandis que Quarkus déplace cette analyse au moment du build pour optimiser le démarrage et l’exécution dans le cloud.

%%Spring prépare beaucoup de choses au démarrage. Quarkus prépare surtout avant, à la compilation.%%

---
## Exemple concret : restaurant vs Food-truck
> [!example] Restaurant 1→ Spring 
> - Les clients arrivent.  
> - Le personnel commence à : 
> 	- installer les tables
> 	- préparer la cuisine 
> 	- organiser la salle
> 	- vérifier le matériel
> 
➡️ Le restaurant finit par être prêt… mais il faut attendre un peu.

> [!attention] Application traditionnelle / monolithe
 >- une énorme cuisine centrale
> - si ça casse → tout s’arrête
>-  difficile à agrandir rapidement

---
> [!example] Restaurant 2 → Quarkus
> - Avant l’ouverture : 
> 	- tout est déjà installé
> 	- la cuisine est prête
> 	- le menu est organisé 
> 
Quand les clients arrivent :
➡️ Le restaurant fonctionne immédiatement.

> [!attention] Application cloud-native / microservices
> 
> - plusieurs petits stands spécialisés
> - si un stand tombe, les autres continuent
> - on peut ajouter facilement des stands quand il y a du monde

---
## Avantages et limites

### Avantages
- démarrage très rapide
- faible RAM
- idéal microservices
- live reload pratique
### Inconvénients
- écosystème plus jeune que Spring
- native image parfois complexe *(Certaines bibliothèques Java utilisent la réflexion et doivent être adaptées pour le mode natif.)* %%Tout doit être connu au build, moins de dynamique%%
- moins fréquent dans certains SI legacy %%Les anciens systèmes n’ont pas les mêmes besoins cloud%%

%%Quarkus n’est pas meilleur ou moins bon que Spring, il répond à des besoins différents : le cloud moderne.%%

---
## Quand utiliser Quarkus ?

#### Bon choix pour :
- APIs modernes
- microservices
- applications cloud
- projets containerisés
#### Moins adapté pour :
- gros monolithes existants
- équipes uniquement habituées à Spring

---
### Ressources utiles

- **Site officiel** : [https://quarkus.io](https://quarkus.io)
- **Guides** : [https://quarkus.io/guides/](https://quarkus.io/guides/)
- **Extensions** : [https://quarkus.io/extensions/](https://quarkus.io/extensions/)
- **GitHub** : [https://github.com/quarkusio/quarkus](https://github.com/quarkusio/quarkus)